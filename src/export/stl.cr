# STL file format writer
# Supports both ASCII and binary STL formats

require "./marching_cubes"

module GS
  module Export
    # STL file writer
    class STLWriter
      # Write mesh to binary STL file (smaller, faster)
      def self.write_binary(mesh : Mesh, path : String, name : String = "mesh")
        File.open(path, "wb") do |file|
          # 80-byte header
          header = Bytes.new(80, 0_u8)
          name_bytes = name.to_slice
          copy_size = Math.min(name_bytes.size, 80)
          copy_size.times { |i| header[i] = name_bytes[i] }
          file.write(header)

          # Triangle count (4 bytes, little-endian)
          triangle_count = mesh.triangle_count.to_u32
          write_u32(file, triangle_count)

          # Write each triangle
          mesh.triangle_count.times do |i|
            i0 = mesh.triangles[i * 3]
            i1 = mesh.triangles[i * 3 + 1]
            i2 = mesh.triangles[i * 3 + 2]

            # Get vertices
            v0 = get_vertex(mesh, i0)
            v1 = get_vertex(mesh, i1)
            v2 = get_vertex(mesh, i2)

            # Compute face normal
            normal = compute_normal(v0, v1, v2)

            # Write normal (3 floats)
            write_f32(file, normal[0])
            write_f32(file, normal[1])
            write_f32(file, normal[2])

            # Write vertices (9 floats total)
            write_f32(file, v0[0])
            write_f32(file, v0[1])
            write_f32(file, v0[2])
            write_f32(file, v1[0])
            write_f32(file, v1[1])
            write_f32(file, v1[2])
            write_f32(file, v2[0])
            write_f32(file, v2[1])
            write_f32(file, v2[2])

            # Attribute byte count (2 bytes, usually 0)
            write_u16(file, 0_u16)
          end
        end
      end

      # Write mesh to ASCII STL file (human-readable, larger)
      def self.write_ascii(mesh : Mesh, path : String, name : String = "mesh")
        File.open(path, "w") do |file|
          file.puts "solid #{name}"

          mesh.triangle_count.times do |i|
            i0 = mesh.triangles[i * 3]
            i1 = mesh.triangles[i * 3 + 1]
            i2 = mesh.triangles[i * 3 + 2]

            v0 = get_vertex(mesh, i0)
            v1 = get_vertex(mesh, i1)
            v2 = get_vertex(mesh, i2)

            normal = compute_normal(v0, v1, v2)

            file.puts "  facet normal #{normal[0]} #{normal[1]} #{normal[2]}"
            file.puts "    outer loop"
            file.puts "      vertex #{v0[0]} #{v0[1]} #{v0[2]}"
            file.puts "      vertex #{v1[0]} #{v1[1]} #{v1[2]}"
            file.puts "      vertex #{v2[0]} #{v2[1]} #{v2[2]}"
            file.puts "    endloop"
            file.puts "  endfacet"
          end

          file.puts "endsolid #{name}"
        end
      end

      # Default: write binary (smaller, faster)
      def self.write(mesh : Mesh, path : String, name : String = "mesh", binary : Bool = true)
        if binary
          write_binary(mesh, path, name)
        else
          write_ascii(mesh, path, name)
        end
      end

      private def self.get_vertex(mesh : Mesh, idx : Int32) : {Float32, Float32, Float32}
        {
          mesh.vertices[idx * 3],
          mesh.vertices[idx * 3 + 1],
          mesh.vertices[idx * 3 + 2],
        }
      end

      private def self.compute_normal(
        v0 : {Float32, Float32, Float32},
        v1 : {Float32, Float32, Float32},
        v2 : {Float32, Float32, Float32}
      ) : {Float32, Float32, Float32}
        # Edge vectors
        e1x = v1[0] - v0[0]
        e1y = v1[1] - v0[1]
        e1z = v1[2] - v0[2]

        e2x = v2[0] - v0[0]
        e2y = v2[1] - v0[1]
        e2z = v2[2] - v0[2]

        # Cross product
        nx = e1y * e2z - e1z * e2y
        ny = e1z * e2x - e1x * e2z
        nz = e1x * e2y - e1y * e2x

        # Normalize
        len = Math.sqrt(nx * nx + ny * ny + nz * nz).to_f32
        if len > 1e-10_f32
          {nx / len, ny / len, nz / len}
        else
          {0.0_f32, 0.0_f32, 1.0_f32}
        end
      end

      private def self.write_u16(io : IO, value : UInt16)
        bytes = Bytes.new(2)
        IO::ByteFormat::LittleEndian.encode(value, bytes)
        io.write(bytes)
      end

      private def self.write_u32(io : IO, value : UInt32)
        bytes = Bytes.new(4)
        IO::ByteFormat::LittleEndian.encode(value, bytes)
        io.write(bytes)
      end

      private def self.write_f32(io : IO, value : Float32)
        bytes = Bytes.new(4)
        IO::ByteFormat::LittleEndian.encode(value, bytes)
        io.write(bytes)
      end
    end

    # OBJ file writer (alternative format)
    class OBJWriter
      def self.write(mesh : Mesh, path : String)
        File.open(path, "w") do |file|
          file.puts "# OBJ file generated by GS 3D Scanner"
          file.puts "# Vertices: #{mesh.vertex_count}"
          file.puts "# Faces: #{mesh.triangle_count}"
          file.puts

          # Write vertices
          (mesh.vertices.size // 3).times do |i|
            x = mesh.vertices[i * 3]
            y = mesh.vertices[i * 3 + 1]
            z = mesh.vertices[i * 3 + 2]
            file.puts "v #{x} #{y} #{z}"
          end

          file.puts

          # Write normals
          (mesh.normals.size // 3).times do |i|
            nx = mesh.normals[i * 3]
            ny = mesh.normals[i * 3 + 1]
            nz = mesh.normals[i * 3 + 2]
            file.puts "vn #{nx} #{ny} #{nz}"
          end

          file.puts

          # Write faces (1-indexed in OBJ format)
          (mesh.triangles.size // 3).times do |i|
            i0 = mesh.triangles[i * 3] + 1
            i1 = mesh.triangles[i * 3 + 1] + 1
            i2 = mesh.triangles[i * 3 + 2] + 1
            # f vertex//normal vertex//normal vertex//normal
            file.puts "f #{i0}//#{i0} #{i1}//#{i1} #{i2}//#{i2}"
          end
        end
      end
    end

    # PLY file writer (Stanford format, good for point clouds)
    class PLYWriter
      def self.write_mesh(mesh : Mesh, path : String, binary : Bool = true)
        if binary
          write_mesh_binary(mesh, path)
        else
          write_mesh_ascii(mesh, path)
        end
      end

      def self.write_points(points : Tensor, path : String, binary : Bool = true)
        if binary
          write_points_binary(points, path)
        else
          write_points_ascii(points, path)
        end
      end

      private def self.write_mesh_binary(mesh : Mesh, path : String)
        File.open(path, "wb") do |file|
          # Header
          file.print "ply\n"
          file.print "format binary_little_endian 1.0\n"
          file.print "element vertex #{mesh.vertex_count}\n"
          file.print "property float x\n"
          file.print "property float y\n"
          file.print "property float z\n"
          file.print "property float nx\n"
          file.print "property float ny\n"
          file.print "property float nz\n"
          file.print "element face #{mesh.triangle_count}\n"
          file.print "property list uchar int vertex_indices\n"
          file.print "end_header\n"

          # Vertices with normals
          mesh.vertex_count.times do |i|
            write_f32(file, mesh.vertices[i * 3])
            write_f32(file, mesh.vertices[i * 3 + 1])
            write_f32(file, mesh.vertices[i * 3 + 2])
            write_f32(file, mesh.normals[i * 3])
            write_f32(file, mesh.normals[i * 3 + 1])
            write_f32(file, mesh.normals[i * 3 + 2])
          end

          # Faces
          mesh.triangle_count.times do |i|
            file.write_byte(3_u8)  # 3 vertices per face
            write_i32(file, mesh.triangles[i * 3])
            write_i32(file, mesh.triangles[i * 3 + 1])
            write_i32(file, mesh.triangles[i * 3 + 2])
          end
        end
      end

      private def self.write_mesh_ascii(mesh : Mesh, path : String)
        File.open(path, "w") do |file|
          file.puts "ply"
          file.puts "format ascii 1.0"
          file.puts "element vertex #{mesh.vertex_count}"
          file.puts "property float x"
          file.puts "property float y"
          file.puts "property float z"
          file.puts "property float nx"
          file.puts "property float ny"
          file.puts "property float nz"
          file.puts "element face #{mesh.triangle_count}"
          file.puts "property list uchar int vertex_indices"
          file.puts "end_header"

          mesh.vertex_count.times do |i|
            x = mesh.vertices[i * 3]
            y = mesh.vertices[i * 3 + 1]
            z = mesh.vertices[i * 3 + 2]
            nx = mesh.normals[i * 3]
            ny = mesh.normals[i * 3 + 1]
            nz = mesh.normals[i * 3 + 2]
            file.puts "#{x} #{y} #{z} #{nx} #{ny} #{nz}"
          end

          mesh.triangle_count.times do |i|
            i0 = mesh.triangles[i * 3]
            i1 = mesh.triangles[i * 3 + 1]
            i2 = mesh.triangles[i * 3 + 2]
            file.puts "3 #{i0} #{i1} #{i2}"
          end
        end
      end

      private def self.write_points_binary(points : Tensor, path : String)
        points_cpu = points.on_cpu? ? points : points.to_cpu
        n_points = points_cpu.shape[0]
        points_d = points_cpu.cpu_data.not_nil!

        File.open(path, "wb") do |file|
          file.print "ply\n"
          file.print "format binary_little_endian 1.0\n"
          file.print "element vertex #{n_points}\n"
          file.print "property float x\n"
          file.print "property float y\n"
          file.print "property float z\n"
          file.print "end_header\n"

          n_points.times do |i|
            write_f32(file, points_d[i * 3])
            write_f32(file, points_d[i * 3 + 1])
            write_f32(file, points_d[i * 3 + 2])
          end
        end
      end

      private def self.write_points_ascii(points : Tensor, path : String)
        points_cpu = points.on_cpu? ? points : points.to_cpu
        n_points = points_cpu.shape[0]
        points_d = points_cpu.cpu_data.not_nil!

        File.open(path, "w") do |file|
          file.puts "ply"
          file.puts "format ascii 1.0"
          file.puts "element vertex #{n_points}"
          file.puts "property float x"
          file.puts "property float y"
          file.puts "property float z"
          file.puts "end_header"

          n_points.times do |i|
            x = points_d[i * 3]
            y = points_d[i * 3 + 1]
            z = points_d[i * 3 + 2]
            file.puts "#{x} #{y} #{z}"
          end
        end
      end

      private def self.write_f32(io : IO, value : Float32)
        bytes = Bytes.new(4)
        IO::ByteFormat::LittleEndian.encode(value, bytes)
        io.write(bytes)
      end

      private def self.write_i32(io : IO, value : Int32)
        bytes = Bytes.new(4)
        IO::ByteFormat::LittleEndian.encode(value, bytes)
        io.write(bytes)
      end
    end
  end
end
